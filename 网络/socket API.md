## 网络编程API

#### 1. close函数

这个函数会对套接字引用计数减一，一旦发现套接字引用计数到 0，就会对套接字进行彻底释放，并且会关闭**TCP 两个方向的数据流**。

套接字可以被多个进程共享，通过fork产生子进程，套接字引用计数+1，调用close，套接字引入计数-1。

close工作流程：

在输入方向，内核会将该socket设置为不可读，任何读操作都会返回异常。

在输出方向，内核尝试将发往缓冲区的数据发送给对端，并最后向对端发送一个FIN分节，接下来如果再对该socket进行写操作会返回异常。

如果对端没有监测到socket已关闭，还继续发送报文，就会收到一个RST报文，告诉对端：“Hi，我已经关闭了，别再给我发数据了。“

close函数并不能帮助我们关闭连接的一个方向，解决这个问题就是shutdown函数。

#### 2. shutdown函数

```c
int shutdown(int sockfd, int howto);
```

参数`howto`选项：

* SHUT_RD(0)：关闭连接的”读“，对该socket进行读操作直接返回EOF。socket上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行ACK，然后悄悄地丢弃。
* SHUT_WR(1)：关闭连接的”写“，这就是常被称为”半关闭“的连接。此时，不管socket引用计数的值是多少，都会直接关闭连接的写。socket发送缓冲区已有的数据将被立即发送出去，并发送一个FIN分节给对端。应用程序对该socket写操作会报错。
* SHUT_RDWR(2)：相当于SHUT_RD和SHUT_WR各操作一次，关闭读和写两个方向。

#### 3. close和shutdown的区别

* close会关闭连接，并释放所有连接对应的资源，而shutdown并不会释放到socket和所有的资源
* close存在引用计数概念，并不一定导致该socket不可用；shutdown则直接使得socket不可用
* close引用计数导致不一定会发出FIN结束分节，shutdown则总是会发出FIN结束分节，这在我们打算关闭连接通知对端的时候，是非常重要的。



