## JVM垃圾回收算法

### 1 堆

* 线程共享
* 在JVM启动时创建
* 垃圾回收的主要场所
* 堆可分为新生代（Eden区，From Survior， To Survivor）、老年代
* 堆可以处于物理上不连续的内存空间，但在逻辑上视为连续

### 2 OutOfMemoryError

1. 堆已满，无法分配内存
2. 栈内存无法动态申请到足够的内存
3. 方法区和运行时常量池溢出
4. 直接内存溢出（特征：HeapDump文件很小，而程序中又直接或者间接使用了DirectMemory（NIO））

### 3 可达性分析

1. JVM栈中引用的对象，例如各个线程被调用的方法堆栈中使用的参数，局部变量，临时变量等
2. 方法区中类静态属性引用的对象，例如Java类的引用类型静态变量
3. 方法区中常来那个引用的对象，例如常量池里的引用
4. 本地方法栈中JNI引用的对象
5. JVM内部的引用，例如基本数据类型对应的Class对象，常驻内存的异常对象（OutMemoryError等）
6. 所有被同步锁（synchronized关键字）持有的对象

### 4 垃圾收集算法

#### 4.1 分代收集理论

三个假设：

1. 绝大多数对象都是朝生夕死的
2. 熬过越多次GC过程的对象就越难以消亡
3. 跨代引用是极少数发生的

#### 4.2 标记-清除算法

标记出所有需要回收的对象（标记出所有存活的对象）

缺点：

1. 性能随对象数量的增长而下降
2. 内存碎片

#### 4.3 标记-复制算法（新生代）

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存使用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。

优点：实现简单，效率高（分配内存时只需移动堆顶指针，按顺序分配，不需要考虑内存碎片）

缺点：浪费内存

#### 4.4 标记-整理算法（老年代）

### 5 新生代与老年代

* 老年代比新生代生命周期长
* 新生代与老年代空间默认比例1:2，JVM参数: XX:NewRatio=2, 表示新生代占1，老年代占2
* Eden空间和两个Survior空间缺省空间占比：8:1:1
* 几乎所有的Java对象都是在Eden区被new出来的，Eden区放不下的大对象，就直接进入老年代了。

#### 5.1 对象分配过程

##### 5.1.1 第1次YGC 

1. new的对象先放在Eden区，大小有限制
2. 如果new对象时，Eden空间满了，触发MinorGC，将Eden区中的垃圾对象清理，再加载新的对象放到Eden区。特别注意的是Survior区满了是不会触发MinorGC的，而是Eden空间满了，MinorGC才顺便清理Survior区
3. 然后将Eden区中剩余存活的对象移动到Survior0区，每个对象被分配了一个年代计数器，每进行一次GC，幸存下来的对象age+1。
4. GC完成后，Eden区是空的。

**说明**

1. S0区和S1区，也成为From区和To区，谁是空的谁就是S1，另外一个就是S0
2. 每次YGC时，幸存的对象会被放入到S1

##### 5.1.2 第2次YGC

1. 当Eden区再次满时，触发第2次YGC，将Eden区幸存的对象放入到S1，幸存对象的age=1
2. 同时对S0区的对象进行判断是否还被使用，如果被使用的话，就将其放入S1，age累加1
3. 第2次GC完成后，S0区为空，此时S0为To区，S1为From区

##### 5.1.3 第N次YGC

1. 第N次YGC时，我们发现S1区的有两个对象的age已经是15了，如果此时这个对象还是被引用的，则将其晋升到Old区
2. 15是默认阈值，可以通过-XX:MaxTenuringThreshold=<N>来设定

### 6 两大主流收集器

#### 6.1 CMS收集器

* 初始标记
* 并发标记
* 重新标记
* 并发清除

CMS默认的回收线程数量：（CPU核心数量+3）/ 4

#### 5.2 G1收集器

G1之前出现的所有收集器，包括CMS，垃圾收集的目标范围要么是整个新生代，要么是整个老年代，或者整个Java堆（Full GC），而G1垃圾收集的标准不再基于垃圾属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。

* Region内存布局

  G1仍然遵循分代收集理论，但不再坚持规定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间，Survior空间，或者老年代。

* 大对象存储区Humongous

  大小超过Region容量（ --XX:G1HeapRegionSize）的一半即可判定为大对象。

* 每次回收若干个Region区

* Region回收优先级 （--XX:MaxGCPauseMillis）



