## JVM内存模型

JVM分为堆区、栈区、方法区。

#### 1 程序计数器

记录当前线程所执行的字节码的行号指示器，每个线程都有一个独立的程序计数器，现成之间的计数器互不影响，独立存储，属于线程私有数据

#### 2 java虚拟机栈

每个方法被执行的时候，java虚拟机都会同步一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法别调佣直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

两类异常：StackOverflowError和OutOfMemoryError

#### 3 本地方法栈

作用与java虚拟机栈非常相似。java虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈为虚拟机所用到的本地（Native）方法服务

#### 4 方法区

存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

#### 6 Java堆

也成GC堆，是虚拟机所管理的内存中最大的一块，在虚拟机启动时创建，此内存区域的唯一目的就是存放java对象的实例。

> > 程序计数器、java虚拟机栈、本地方法栈都是线程私有的数据，随线程创建时而生，随线程消亡时而灭。



## 直接内存

直接内存并不是java虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存数据。但是这部分内存也别频繁地使用，而且也可能产生OOM异常。

在JDK1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这个内存的引用进行操作，这样能在一些场景中显著地提升性能，因为避免了再Java堆和Native堆中来回复制数据。（内存映射）